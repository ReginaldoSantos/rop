{"name":"Rop","tagline":"A lightweight command line option parser written in Java","body":"# Rop\r\n\r\n[![Build Status](https://travis-ci.org/ryenus/rop.png?branch=master)](https://travis-ci.org/ryenus/rop)\r\n\r\nRop is a lightweight command line option parser written in Java.\r\n\r\n## Introduction\r\n\r\nRop is designed to be minimal meanwhile convenient, to cover most usual command line parsing use cases. You can use Rop to build command line programs like:\r\n\r\n* `mv` and `ls`\r\n\r\n    - simple commands that just do one thing\r\n\r\n* `git add`, `git commit`\r\n\r\n    - sub-commands, but single invocation\r\n\r\n* `mvn clean test`\r\n\r\n    - sub-commands with multiple invocations\r\n\r\nMore importantly, Rop endorses building command line option parsers the Java way. Instead of following the traditional [GetOpt](http://en.wikipedia.org/wiki/Getopt) way of building an option parser, Rop follows an approache that is:\r\n\r\n* Annotation based, and\r\n* Object-oriented\r\n\r\nYou can build an option parser by defining Command classes and their fields annotated with the corresponding Option switches.\r\n\r\nAlso, each Command can optionally have a `run()` method to define its behavior, which would be called by the parser automatically.\r\n\r\n### How to start?\r\n\r\nRop is available as a Maven artifact `com.github.ryenus:rop`. Simply add this to the dependencies section in your pom.xml:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.github.ryenus</groupId>\r\n    <artifactId>rop</artifactId>\r\n    <version>1.0</version>\r\n</dependency>\r\n```\r\n\r\nNote that '1.0' might not be the latest version when you're reading this.\r\n\r\nYou can always get the latest source code from https://github.com/ryenus/rop.\r\n\r\n### Usage example\r\n\r\nHere's a quick example to demonstrate how to use Rop:\r\n\r\n```java\r\nimport com.github.ryenus.rop.OptionParser;\r\nimport com.github.ryenus.rop.OptionParser.Command;\r\nimport com.github.ryenus.rop.OptionParser.Option;\r\n\r\n@Command(name = \"foo\", description = \"A simple command with a few options.\")\r\nclass FooCommand {\r\n\t@Option(description = \"explain what is being done\", opt = { \"-V\", \"--verbose\" })\r\n\tboolean verbose;\r\n\r\n\t@Option(description = \"certain number\", opt = { \"-n\", \"--number\" })\r\n\tint n = 3; // default to 3\r\n\r\n\t// This method would be called automatically\r\n\t// Both arguments of the run() methods can be omitted\r\n\tvoid run(OptionParser parser, String[] params) {\r\n\t\tif (verbose) { // 'verbose' is set to true by the parser\r\n\t\t\tSystem.out.println(n); // => 4\r\n\t\t\tfor (String param : params) {\r\n\t\t\t\tSystem.out.println(param);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assume this is called with 'java TheMain --verbose -n 4 a b'\r\npublic static void main(String[] args) {\r\n\tOptionParser parser = new OptionParser(FooCommand.class);\r\n\tparser.parse(args);\r\n}\r\n```\r\n\r\n## Understanding Rop\r\n\r\nThe most significant thing in Rop is the `OptionParser` class, with which Commands are registered, then you call its `parse()` method to parse the command line arguments.\r\n\r\n### The `@Command` Annotation\r\n\r\nAny vanilla class can be turned to a valid Command with the `@Command` annotation.\r\n\r\n### The `@Option` Annotation\r\n\r\nIn a Command class, those fields having the `@Option` annotation, are viable to be set from command line argments during parsing. The above example should make it pretty clear.\r\n\r\n### Command Registration\r\n\r\nThe `OptionParser` class provides a `register()` method to allow a Command, i.e. a class annotated with `@Command`, or its instance, to be registered with the parser. The `register()` method is chainable, as it always returns the parser object.\r\n\r\nA Command can also be registered by passing it directly to the constructor `OptionParser()`, so you don't have to explicitly call the `register()` method. Also, the constructor can be called with any number of Commands.\r\n\r\n### Post Parsing Hook - Method `run`\r\n\r\nA Command can have a little magic. If it has a `run()` method, the parser would call this method at the end of parsing if the Command appeared in the command line.\r\n\r\nIn the above example,  `FooCommand.run()` would be called automatically, it would receive a reference to the parser itself, and an array which consists of all the remaining arguments.\r\n\r\nIf you're not interested in getting either the parser or the parameters, just omit any of them, or both.\r\n\r\nNote that if there're more than one `run()` method, only the first would be called.\r\n\r\n### Sub Command\r\n\r\nTypical commands, such as [`mv`](http://en.wikipedia.org/wiki/Mv) and [`ls`](http://en.wikipedia.org/wiki/Ls) in Unix, are quite simple, they're designed to [do one thing and do it well](http://en.wikipedia.org/wiki/Unix_philosophy).\r\n\r\nHowever, not everything is simple. [Git](http://git-scm.com/) provides a bunch of sub-commands to do many different things, such as `git add`, `git commit` and `git log`.\r\n\r\nWith Rop, you can register just one Command to build a simple command like `mv`, you can also register multiple Commands to support sub-commands like Git.\r\n\r\nThough Git provides many sub-commands, you can only use one sub-command at a time, for example, in `git add ... commit ...`, the argument 'commit' loses its magic and would be treated as something to be added with `git add`, not the sub-command `git commit`.\r\n\r\nBut for [Ant](http://ant.apache.org/) and [Maven](http://maven.apache.org/), it's a different story. As in `mvn clean test`, you can run multiple sub-commands together. Can we do that as well? Sure, it's actually very simple:\r\n\r\nRather than calling\r\n\r\n```java\r\nparser.parse(args)\r\n```\r\n\r\ninstead, call\r\n\r\n```java\r\nparser.parse(args, true)\r\n```\r\n\r\nThe extra boolean argument, when set to 'true', tells the parser to recognize all the sub-commands it detected. For each properly recognized sub-command, its `run()` method, if exists, would be called, in the order they appeared on the command line.\r\n\r\n### Supported Field Types and Default Values\r\n\r\n* String, and all primitive type and their wrapper types are directly supported.\r\n* File, Path are supported as well, but not Date/Time yet.\r\n* There might be a customizable type binder available in the future.\r\n\r\nAs in the above example, a default option value can be directly set to its associated field. If not set, the option values default to their type default, as list above, according to Java Tutorial - [Primitive Data Types](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html).\r\n\r\n<pre>\r\nTypes                   Default Values\r\nboolean                 false\r\nbyte                    0\r\nshort                   0\r\nint                     0\r\nlong                    0L\r\nfloat                   0.0f\r\ndouble                  0.0d\r\nchar                    '\\u0000'\r\nString/Wrapper/Object   null\r\n</pre>\r\n\r\n### Built-in Help\r\n\r\nIf option '--help' is present, the parser will:\r\n\r\n1. display help information constructed from the Commands/Options annotations\r\n2. call System.exit(0)\r\n\r\n### Error Handling\r\n\r\nAny possible error would be thrown as a RuntimeException, or its subclass, provided with proper error massege. You might want to catch the exceptions, print the error message and/or the help information before exiting the program. This is intentionally left to you so that you can control how your program behaves upon parsing errors before terminating.\r\n\r\n## Contributing\r\n\r\nIf you'd like to help improve Rop, clone the project with Git by running:\r\n\r\n    $ git clone https://github.com/ryenus/rop\r\n\r\nWork your magic and then submit a pull request. We love pull requests!\r\n\r\nIf you don't have the time to work on Rop, but found something we should know about, please submit an issue.\r\n\r\n## License\r\n\r\nRop is released under the [MIT License](http://www.opensource.org/licenses/MIT).\r\n\r\n## Related projects\r\n\r\n* [java-getopt](https://github.com/arenn/java-getopt)\r\n* [JOpt Simple](http://pholser.github.com/jopt-simple)\r\n* [JCommander](https://github.com/cbeust/jcommander)\r\n* [Commons CLI](http://commons.apache.org/proper/commons-cli/)\r\n* [joptparse](https://code.google.com/p/joptparse)\r\n","google":"UA-39711562-1","note":"Don't delete this file! It's used internally to help with page regeneration."}